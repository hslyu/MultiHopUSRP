#!/usr/bin/env python3
"""
Estimate the delay between a transmitted waveform and a captured signal.

The tool expects a complex64 `.npy` file generated by waveform_generator.py and a
raw complex64 (`.c32`) capture produced by rx_flowgraph.py. It reports the peak
correlation lag along with derived sample/time delays and basic quality metrics.
"""

from __future__ import annotations

import argparse
import os
from dataclasses import dataclass
from pathlib import Path
from typing import Optional

import numpy as np

_MPL_CACHE_DIR = Path(__file__).resolve().parent / ".matplotlib"
_MPL_CACHE_DIR.mkdir(parents=True, exist_ok=True)
os.environ.setdefault("MPLCONFIGDIR", str(_MPL_CACHE_DIR))

import matplotlib

matplotlib.use("Agg")
import matplotlib.pyplot as plt  # pylint: disable=wrong-import-position


@dataclass
class DelayResult:
    """Container for correlation outputs."""

    sample_delay: int
    time_delay: float
    peak_magnitude: float
    normalized_peak: Optional[float]
    lags: np.ndarray
    correlation: np.ndarray


def _load_waveform(path: Path) -> np.ndarray:
    samples = np.load(path)
    if samples.ndim != 1:
        raise ValueError(f"Waveform '{path}' must be a 1-D array.")
    if not np.iscomplexobj(samples):
        raise ValueError(f"Waveform '{path}' must contain complex samples.")
    return samples.astype(np.complex64, copy=False)


def _load_capture(path: Path) -> np.ndarray:
    if not path.exists():
        raise FileNotFoundError(f"Capture file '{path}' not found.")
    data = np.fromfile(path, dtype=np.complex64)
    if data.size == 0:
        raise ValueError(f"Capture file '{path}' contains no samples.")
    return data


def _next_power_of_two(length: int) -> int:
    if length <= 0:
        raise ValueError("Length must be positive.")
    return 1 << (length - 1).bit_length()


def _fft_convolve(a: np.ndarray, b: np.ndarray) -> np.ndarray:
    size = a.size + b.size - 1
    fft_size = _next_power_of_two(size)
    fa = np.fft.fft(a, fft_size)
    fb = np.fft.fft(b, fft_size)
    result = np.fft.ifft(fa * fb)
    return result[:size]


def _fft_correlate(a: np.ndarray, b: np.ndarray) -> np.ndarray:
    return _fft_convolve(a, np.conj(b[::-1]))


def _select_correlations(
    lags: np.ndarray,
    correlation: np.ndarray,
    *,
    allow_negative: bool,
    max_lag: Optional[int],
) -> tuple[np.ndarray, np.ndarray]:
    mask = np.ones_like(lags, dtype=bool)
    if not allow_negative:
        mask &= lags >= 0
    if max_lag is not None:
        mask &= np.abs(lags) <= max_lag
    if not np.any(mask):
        raise ValueError("No lags remain after applying the search constraints.")
    return lags[mask], correlation[mask]


def estimate_delay(
    tx_samples: np.ndarray,
    rx_samples: np.ndarray,
    *,
    samp_rate: float,
    allow_negative: bool = False,
    max_lag: Optional[int] = None,
) -> DelayResult:
    corr = _fft_correlate(rx_samples, tx_samples)
    lags = np.arange(-(tx_samples.size - 1), rx_samples.size, dtype=np.int64)

    sel_lags, sel_corr = _select_correlations(
        lags, corr, allow_negative=allow_negative, max_lag=max_lag
    )

    peak_index = int(np.argmax(np.abs(sel_corr)))
    peak_lag = int(sel_lags[peak_index])
    peak_value = sel_corr[peak_index]
    sample_delay = peak_lag
    time_delay = sample_delay / samp_rate

    normalized_peak: Optional[float] = None
    if 0 <= peak_lag <= rx_samples.size - tx_samples.size:
        rx_segment = rx_samples[peak_lag : peak_lag + tx_samples.size]
        denom = np.linalg.norm(tx_samples) * np.linalg.norm(rx_segment)
        if denom > 0.0:
            normalized_peak = float(np.abs(np.vdot(tx_samples, rx_segment)) / denom)

    return DelayResult(
        sample_delay=sample_delay,
        time_delay=time_delay,
        peak_magnitude=float(np.abs(peak_value)),
        normalized_peak=normalized_peak,
        lags=sel_lags,
        correlation=sel_corr,
    )


def _build_arg_parser() -> argparse.ArgumentParser:
    parser = argparse.ArgumentParser(
        description="Estimate sample/time delay between TX waveform and RX capture."
    )
    parser.add_argument(
        "--tx-waveform",
        type=Path,
        required=True,
        help="Path to the transmitted complex64 waveform (.npy).",
    )
    parser.add_argument(
        "--rx-capture",
        type=Path,
        required=True,
        help="Path to the recorded capture file produced by rx_flowgraph (.c32).",
    )
    parser.add_argument(
        "--samp-rate",
        type=float,
        default=1e6,
        help="Sample rate in Sa/s used during capture (default: 1e6).",
    )
    parser.add_argument(
        "--max-lag",
        type=int,
        default=None,
        help="Limit the absolute lag search window to +/- max_lag samples.",
    )
    parser.add_argument(
        "--allow-negative",
        action="store_true",
        help="Include negative lags in the search (default: positive lags only).",
    )
    parser.add_argument(
        "--plot",
        type=Path,
        default=None,
        help="Optional path to save the correlation magnitude plot.",
    )
    parser.add_argument(
        "--waveform-plot",
        type=Path,
        default=None,
        help="Optional path to save an amplitude/phase plot of the RX capture.",
    )
    parser.add_argument(
        "--waveform-plot-samples",
        type=int,
        default=None,
        help="Limit waveform plot to the first N samples.",
    )
    parser.add_argument(
        "--print-rx-samples",
        type=int,
        default=0,
        help="Print the first N received samples after loading (0 disables).",
    )
    return parser


def _save_correlation_plot(result: DelayResult, output: Path) -> Path:
    output.parent.mkdir(parents=True, exist_ok=True)
    lags = result.lags
    magnitude = np.abs(result.correlation)

    fig, ax = plt.subplots(figsize=(10, 4), constrained_layout=True)
    ax.plot(lags, magnitude, label="|corr|")
    ax.axvline(result.sample_delay, color="tab:red", linestyle="--", label="Peak lag")
    ax.set_xlabel("Lag [samples]")
    ax.set_ylabel("|Correlation|")
    ax.set_title("Correlation Magnitude vs Lag")
    ax.grid(True, which="both", linestyle=":")
    ax.legend()

    fig.savefig(output)
    plt.close(fig)
    return output


def _save_waveform_plot(
    samples: np.ndarray, output: Path, sample_count: Optional[int] = None
) -> Path:
    output.parent.mkdir(parents=True, exist_ok=True)

    if sample_count is not None:
        if sample_count <= 0:
            raise ValueError("waveform plot sample_count must be positive.")
        plot_samples = samples[:sample_count]
    else:
        plot_samples = samples

    if plot_samples.size == 0:
        raise ValueError("Capture is empty; unable to plot waveform.")

    indices = np.arange(plot_samples.size, dtype=np.int32)
    amplitudes = np.abs(plot_samples)

    fig, axes = plt.subplots(
        2, 1, figsize=(10, 6), constrained_layout=True
    )

    axes[0].plot(indices, amplitudes)
    axes[0].set_ylabel("Amplitude")
    axes[0].set_title("Amplitude Overview")
    axes[0].grid(True, which="both", linestyle=":")

    zoom_start = min(500, plot_samples.size - 1)
    zoom_end = min(1000, plot_samples.size)
    if zoom_start < zoom_end:
        axes[1].plot(indices[zoom_start:zoom_end], amplitudes[zoom_start:zoom_end])
        axes[1].set_xlim(indices[zoom_start], indices[zoom_end - 1])
        axes[1].set_title("Amplitude Detail (Samples 500-1000)")
    else:
        axes[1].plot(indices, amplitudes)
        axes[1].set_title("Amplitude Detail (Showing Available Samples)")
    axes[1].set_xlabel("Sample Index")
    axes[1].set_ylabel("Amplitude")
    axes[1].grid(True, which="both", linestyle=":")

    fig.suptitle("RX Waveform Amplitude")
    fig.savefig(output)
    plt.close(fig)
    return output


def main() -> None:
    parser = _build_arg_parser()
    args = parser.parse_args()

    tx_path: Path = args.tx_waveform
    rx_path: Path = args.rx_capture

    tx_samples = _load_waveform(tx_path)
    rx_samples = _load_capture(rx_path)

    if args.print_rx_samples > 0:
        count = min(args.print_rx_samples, rx_samples.size)
        print(f"First {count} RX samples:")
        for idx in range(count):
            value = rx_samples[idx]
            print(f"n={idx:5d}: {value.real:+.6f} {value.imag:+.6f}j")

    result = estimate_delay(
        tx_samples,
        rx_samples,
        samp_rate=args.samp_rate,
        allow_negative=args.allow_negative,
        max_lag=args.max_lag,
    )

    print(f"TX waveform samples: {tx_samples.size}")
    print(f"RX capture samples: {rx_samples.size}")
    print(f"Sample delay: {result.sample_delay} samples")
    print(f"Time delay: {result.time_delay * 1e6} Âµs ({result.time_delay:.3f} s)")
    print(f"Peak correlation magnitude: {result.peak_magnitude:.6f}")
    if result.normalized_peak is not None:
        print(f"Normalized peak (0-1): {result.normalized_peak:.6f}")
    else:
        print("Normalized peak: unavailable (peak window exceeds capture bounds)")

    if args.plot is not None:
        saved = _save_correlation_plot(result, args.plot)
        print(f"Correlation plot saved to {saved}")

    if args.waveform_plot is not None:
        saved_waveform = _save_waveform_plot(
            rx_samples, args.waveform_plot, sample_count=args.waveform_plot_samples
        )
        print(f"Waveform plot saved to {saved_waveform}")


if __name__ == "__main__":
    main()
